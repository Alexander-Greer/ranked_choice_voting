# *********************************************************************
# Project           : The Haverford School Student Council / Honor Council Elections
# Program name      : ranked_choice_voting.py
# Author            : Alexander Harrison Greer '20
# Date created      : May 9, 2019
# Purpose           : Input ranked choice voting data in an election format and determine the winner(s)
# Revision History  :
#
# Date        Author      Ref    Revision
# YYYYMMDD    TEMPLATE    1      Use this as a template for making revisions.
#
# *********************************************************************


# Import existing python libraries for use throughout the program:

# .csv reader: used to interpret the data found in a .csv file, as in the input format
import csv

# math and numpy: used to display / interpret mathematical operations throughout the program
import math
import numpy as np


# unique()
# This function takes an input of a python list and outputs a numpy array of all the unique items from the list.
def unique(input_list):
    x = np.array(input_list)
    return np.unique(x)


# gather_votes()
# This function turns a .csv file full of votes (as downloaded from a spreadsheet generated by a Google Form, e.g.) ...
# into a python list where each item represents a voter. Each voter is another list filled with the voters' chosen
# candidates in order.
def gather_votes(input_file):
    output_list = []

    placeholder_list = []
    with open(input_file) as csv_file:
        csv_reader = csv.reader(csv_file, delimiter=',')
        current_row = 0
        current_column = 0
        for voter_row in csv_reader:

            # to not include header
            if current_row != 0:

                for vote_column in voter_row:

                    if current_column != 0:
                        if vote_column != '':
                            placeholder_list.append(vote_column)
                            print(vote_column + " ", end='')

                    current_column += 1

                output_list.append(placeholder_list)

            placeholder_list = []

            current_column = 0
            print("")

            current_row += 1

    print("")
    return output_list


# tally_votes()
# This function is used repeatedly throughout the function as a way to interpret the votes gathered using gather_votes()
# or otherwise modified throughout the program. It counts the number of instances in which a candidate is ranked first
# in a voter's choices and outputs the result as a list with each item being another list containing the candidate and
# his/her number of votes.
def tally_votes(list_of_candidates, input_list, reapportioned_list, list_of_secured_candidates):

    # initialize two temporary lists to be used in this function
    output = []
    placeholder_list = []

    # remove any exhausted votes
    for voter in input_list:
        try:
            if voter[0] not in list_of_candidates:
                input_list.remove(voter)

        except ValueError:
            print("-----")

        try:
            if voter[0] in list_of_secured_candidates:
                input_list.remove(voter)

        except ValueError:
            print("- - -")

    # for every candidate in the list provided...
    for candidate in list_of_candidates:
        # append the name of the candidate and a number (0) to a smaller list within the output
        placeholder_list.append(candidate)
        placeholder_list.append(0)

        # if there are more instances of that candidate in the input, increase the tally for that candidate
        for vote in input_list:
            if vote[0] == candidate and vote[0] != "least":
                placeholder_list[1] += 1

        for reapportioned_candidate in reapportioned_list:
            if reapportioned_candidate[0] == candidate:
                placeholder_list[1] += reapportioned_candidate[1]

        # add the smaller list into the growing list of candidates and associated votes
        output.append(placeholder_list)

        # reset the placeholder list
        placeholder_list = []

    return output


# cleanse_empty_votes()
# This function is used sparingly in the event that a voter's chosen list of candidates are all eliminated during the
# tallying process. This function is used to catch any empty lists in case in order to prevent any program errors.
def cleanse_empty_votes(input_votes):
    for vote in input_votes:
        if vote == []:
            input_votes.remove(vote)


# reapportion()
# This is the main function of the program. It takes the input of the gathered votes and tallies them appropriately
# according to RCV standards. It first eliminates the candidate with the lowest number of votes. Then it re-tallies the
# votes to include the elimination, adding the eliminated candidate(s)' next ranked choice. The second step is to check
# if a candidate has reached the appropriate threshold and, if so, reapportion the extra votes (if any) to their next
# choice candidates. This function is run in a loop until the desired number of candidates is reached.
def reapportion(votes, vote_threshold, secured_candidates, reapportioned_list):

    tallied_votes = tally_votes(LIST_OF_CANDIDATES, votes, reapportioned_list, secured_candidates)

    # This if statement is a simplification step to reduce program time. If there are fewer than three candidates
    # remaining (i.e. two), then the complex reapportioning process does not need to take place, and the one with
    # the higher number of votes can simply be added to the chosen candidates and the other eliminated.
    if len(tallied_votes) > 3:

        cleanse_empty_votes(votes)

        tallied_votes = tally_votes(LIST_OF_CANDIDATES, votes, reapportioned_list, secured_candidates)

        # STEP 1:
        # Eliminate the candidate with the lowest number of votes
        # (Note: if there is a tie for lowest ranked candidate, both are eliminated)
        # Reapportion the lowest-ranked candidate's voters' votes to their next choices.

        print("Tallied Votes: " + str(tallied_votes))
        voting_tallies = list(map(float, np.array(tallied_votes).T.tolist()[1]))

        # Main function of step one: if there is a candidate in the list of tallied votes that has reached or surpassed
        # the threshold, remove it from all the lists in which it may contribute to future tallies.
        for tallied_vote in tallied_votes:
            if float(tallied_vote[1]) == float(min(voting_tallies)):
                print("Eliminate Candidate " + str(tallied_vote[0]) + "'s First Choice Votes")

                # remove from the tallied vote list
                tallied_votes.remove(tallied_vote)

                # remove from the total votes list
                for voter in votes:
                    # if the voter's first choice is the vote for the candidate that must be eliminated
                    if voter[0] == tallied_vote[0] and voter[-1] != "least":
                        voter.pop(0)
                        voter.append("least")

                # remove from the running list of candidates
                LIST_OF_CANDIDATES.remove(tallied_vote[0])

                # remove the candidate from the growing list of vote tallies that have been reapportioned
                # i.e. remove the "exhausted" votes
                try:
                    for candidate in reapportioned_list:
                        if candidate[0] == tallied_vote[0]:
                            reapportioned_list.remove(candidate)
                except ValueError:
                    print("Candidate already removed")

        # remove
        try:
            for candidate in reapportioned_list:
                if candidate[0] in secured_candidates:
                    reapportioned_list.remove(candidate)
        except ValueError:
            print("Candidate already removed")

        cleanse_empty_votes(votes)

        # re-tally the votes
        tallied_votes = tally_votes(LIST_OF_CANDIDATES, votes, reapportioned_list, secured_candidates)

        print("Votes (with Removals): " + str(votes))
        print("Tallied Votes (with Removals): " + str(tallied_votes))
        print("List of Candidates (with Removals): " + str(LIST_OF_CANDIDATES))

        # STEP 2:
        # Check to see if a candidate has already reached the threshold.
        # If so, reapportion the extra votes to their voters' second choices.

        # if a candidate has already passed the threshold, reapportion the candidate's votes to the voters' next choices
        for candidate in tallied_votes:
            if candidate[1] >= vote_threshold:
                # add the candidate to the list of secured candidates
                secured_candidates.append(candidate[0])
                print(candidate)

                # calculate what fraction of the candidate's voters' votes need to be reapportioned
                fraction = (candidate[1] - vote_threshold) / float(candidate[1])
                print("Reapportion fraction: " + str(candidate[1] - vote_threshold) + "/" + str(candidate[1]))

                # iterate through every vote ...
                for voter in votes:
                    # if the current voter voted for the secured candidate as their first choice,
                        # remove the secured candidate's vote from the growing tally
                    if voter[0] == candidate[0]:
                        voter.pop(0)
                        print(tallied_votes)

                print(votes)
                cleanse_empty_votes(votes)
                print(votes)

                for voter in votes:

                    for reapportioned_candidate in reapportioned_list:
                        try:
                            if reapportioned_candidate[0] == voter[0]:
                                reapportioned_candidate[1] += fraction
                            # print(reapportioned_list)

                        except ValueError:
                            print("candidate already eliminated!")

                candidate[1] -= (candidate[1] - vote_threshold)
                LIST_OF_CANDIDATES.remove(candidate[0])

        cleanse_empty_votes(votes)

        tallied_votes = tally_votes(LIST_OF_CANDIDATES, votes, reapportioned_list, secured_candidates)

        print("Votes (with Reapp): " + str(votes))
        print("Tallied Votes (with Reapp): " + str(tallied_votes))
        print("List of Candidates (with Reapp): " + str(LIST_OF_CANDIDATES))

    # (i.e. if there are only two candidates left)
    else:
        print("No More Reapportioning Necessary!")
        if tallied_votes[0][1] > tallied_votes[1][1]:
            secured_candidates.append(tallied_votes[0][0])
        else:
            secured_candidates.append(tallied_votes[1][0])

    # the final return: the list containing the secured candidates
    return secured_candidates


# how many candidates do you want to win?
SENIOR_PRIMARIES_NUM_OF_CANDIDATES = 3

VOTES = gather_votes("election_results_test.csv")
print("VOTES:" + str(VOTES))

# Initialize a list that will contain all of the unique candidates
# list combination found @ https://stackoverflow.com/questions/716477/join-list-of-lists-in-python
LIST_OF_CANDIDATES = list(unique(sum(VOTES, [])).tolist())

print("List of Candidates:" + str(LIST_OF_CANDIDATES))

number_of_votes_cast = len(VOTES)
VOTE_THRESHOLD = 1 + math.floor(number_of_votes_cast/(SENIOR_PRIMARIES_NUM_OF_CANDIDATES+1))
print("Vote Threshold: " + str(VOTE_THRESHOLD) + " votes")

# Initialize a list to be filled with the secured candidates as they are tabulated
SECURED_CANDIDATES = []

REAPPORTIONED_LIST = [[LIST_OF_CANDIDATES[i], 0] for i in range(len(LIST_OF_CANDIDATES))]
print(REAPPORTIONED_LIST)

print("")

# Initialize the round counter
round_counter = 1

# i.e. while there are more than the chosen number of candidates left
while len(SECURED_CANDIDATES) < SENIOR_PRIMARIES_NUM_OF_CANDIDATES:

    # print a tally displaying the number of rounds elapsed
    print("Current Round: " + str(round_counter))

    # perform the "reapportion" function on the input of tallied votes (In an [A, 4], [B, 2], etc. format)
    print("Secured Candidates:" + str(reapportion(VOTES, VOTE_THRESHOLD, SECURED_CANDIDATES, REAPPORTIONED_LIST)))

    # print a space between rounds and iterate the round counter
    print("")
    round_counter += 1
